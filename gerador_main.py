# -*- coding: utf-8 -*-
"""gerador_main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CVQi_ldz7g1p7IFF4-nCD88zMAQW_00n
"""

# !apt-get install -y lilypond

from music21 import *

# === cria√ß√£o da melodia original (C maior) ===
melody = stream.Part()
melody.id = 'Violin 1 (Melody)'

'''
Cada tupla representa (nota, dura√ß√£o).
Exemplo: ("C5", 0.5) = nota D√≥ na quinta oitava com meia batida.
1.0 = nota de um tempo completo.
'''
notes = [
    ("C5", 0.5), ("D5", 0.5), ("E5", 1.0), ("C5", 1.0),
    ("E5", 0.5), ("F5", 0.5), ("G5", 1.0), ("G5", 1.0),
    ("G5", 0.5), ("F5", 0.5), ("E5", 1.0), ("F5", 1.0),
    ("E5", 0.5), ("D5", 0.5), ("C5", 1.0), ("C5", 1.0)
]

'''
Esse for cria cada note.Note e define a dura√ß√£o em m√≠nimas ou sem√≠nimas (dependendo do valor).
Depois, adiciona tudo √† pauta do Violino I.
'''
for pitch_name, dur in notes:
    n = note.Note(pitch_name)
    n.quarterLength = dur
    melody.append(n)

# === Transposi√ß√£o para D√≥ menor harm√¥nico ===
'''
Neste exemplo, que √© a partitura original da Marcha Soldado, a tonalidade era D√≥ maior (C major).
key.Key('C', 'minor') √© D√≥ menor natural
'''
melody_minor = melody.transpose('P1')
key_c_minor = key.Key('C', 'minor')
melody_minor.insert(0, key_c_minor)

'''
O modo harm√¥nico de D√≥ menor usa:
C D Eb F G Ab B
(diferen√ßa: o E vira Eb, e o A vira Ab).
O loop percorre todas as notas e altera manualmente essas alturas.
Assim, a melodia fica de acordo com o modo harm√¥nico.
'''
# Ajusta notas manualmente para a escala harm√¥nica (E -> Eb, A -> Ab)
adjust_map = {"E": "Eb", "A": "Ab"}
for n in melody_minor.recurse().notes:
    pitch_name = n.name[0]
    if pitch_name in adjust_map:
        n.name = adjust_map[pitch_name]

# === Cria√ß√£o da linha de contracanto (violino 2) ===
violin2 = stream.Part()
violin2.id = 'Violin 2 (Countermelody)'

'''
Essa linha foi feita para soar em ter√ßas e sextas abaixo/acima da melodia, criando uma textura de contracanto simples e coesa.
'''
counter_notes = [
    ("Ab4", 0.5), ("Bb4", 0.5), ("C5", 1.0), ("Ab4", 1.0),
    ("C5", 0.5), ("Db5", 0.5), ("Eb5", 1.0), ("Eb5", 1.0),
    ("Eb5", 0.5), ("Db5", 0.5), ("C5", 1.0), ("Db5", 1.0),
    ("C5", 0.5), ("Bb4", 0.5), ("Ab4", 1.0), ("Ab4", 1.0)
]

# Cria as notas e adiciona √† pauta do Violino II.
for pitch_name, dur in counter_notes:
    n = note.Note(pitch_name)
    n.quarterLength = dur
    violin2.append(n)

violin2.insert(0, key_c_minor)

# === Define nomes e instrumentos visuais ===
melody_minor.partName = "Violino I (Melodia)"
violin2.partName = "Violino II (Contracanto)"

melody_minor.insert(0, instrument.Violin())
violin2.insert(0, instrument.Violin())

# === Cria√ß√£o da partitura ===
score = stream.Score()
score.insert(0, metadata.Metadata())
score.metadata.title = "Marcha Soldado ‚Äî Vers√£o em D√≥ Menor Harm√¥nico"
score.metadata.composer = "Arranjo: Maria & Music21"

# Insere as partes na ordem correta (melodia em cima)
score.insert(0, melody_minor)
score.insert(1, violin2)

# === Exporta√ß√£o ===
musicxml_path = '/content/Marcha_Soldado_Cm_harmonic.musicxml'

score.write('musicxml', fp=musicxml_path)

print("‚úÖ Arquivo MusicXML gerado com sucesso!")
print("üéº Caminho:", musicxml_path)